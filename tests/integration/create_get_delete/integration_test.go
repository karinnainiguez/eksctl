// +build integration

package create_get_delete

import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"testing"
	"time"

	awseks "github.com/aws/aws-sdk-go/service/eks"
	harness "github.com/dlespiau/kube-test-harness"
	"github.com/dlespiau/kube-test-harness/logger"
	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
	"github.com/onsi/gomega/gexec"
	"github.com/weaveworks/eksctl/pkg/testutils/aws"
	. "github.com/weaveworks/eksctl/pkg/testutils/matchers"
	"github.com/weaveworks/eksctl/tests/integration"
	//"k8s.io/client-go/tools/clientcmd"
)

const (
	clusterName         = "int-cluster"
	createTimeoutInMins = 20
	eksRegion           = "us-west-2"
)

var (
	pathToEksCtl      string
	autoGeneratedConf bool

	// Flags to help with developing the integration tests
	skipCreation    bool
	skipCleanup     bool
	pathKubeCtlConf string
)

func TestCreateIntegration(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Integration - Create Suite")
}

var _ = Describe("Create (Integration)", func() {

	BeforeSuite(func() {
		if pathKubeCtlConf == "" {
			currentdir, _ := os.Getwd()
			tempFile, _ := ioutil.TempFile(currentdir, "kubeconf")
			pathKubeCtlConf = tempFile.Name()
			autoGeneratedConf = true
		}
		fmt.Printf("Using kubeconfig: %s\n", pathKubeCtlConf)
	})

	AfterSuite(func() {
		gexec.KillAndWait()
		if !skipCleanup {
			integration.CleanupAws(clusterName, eksRegion)
			if autoGeneratedConf {
				os.Remove(pathKubeCtlConf)
			}
		}
	})

	Describe("when creating a cluster with 1 node", func() {
		var (
			err     error
			session *gexec.Session
		)

		It("should not return an error", func() {
			if skipCreation {
				fmt.Printf("Creation test skip: %t\n", skipCreation)
				return
			}

			args := []string{"create", "cluster", "-n", clusterName, "-t", "t2.medium", "-N", "1", "-r", eksRegion, "--kubeconfig", pathToEksCtl}

			command := exec.Command(pathToEksCtl, args...)
			session, err = gexec.Start(command, GinkgoWriter, GinkgoWriter)

			if err != nil {
				Fail(fmt.Sprintf("error starting process: %v", err), 1)
			}

			session.Wait(createTimeoutInMins * time.Minute)
			Expect(session.ExitCode()).Should(Equal(0))
		})

		It("should have created an EKS cluster", func() {
			session := aws.NewSession(eksRegion)
			Expect(session).To(HaveEksCluster(clusterName, awseks.ClusterStatusActive, "1.10"))
		})

		It("should have the required cloudformation stacks", func() {
			session := aws.NewSession(eksRegion)

			Expect(session).To(HaveCfnStack(fmt.Sprintf("EKS-%s-VPC", clusterName)))
			Expect(session).To(HaveCfnStack(fmt.Sprintf("EKS-%s-ControlPlane", clusterName)))
			Expect(session).To(HaveCfnStack(fmt.Sprintf("EKS-%s-ServiceRole", clusterName)))
			Expect(session).To(HaveCfnStack(fmt.Sprintf("EKS-%s-DefaultNodeGroup", clusterName)))
		})

		/*It("should have created a valid kubectl config file", func() {
			config, err := clientcmd.LoadFromFile(pathKubeCtlConf)
			Expect(err).ShouldNot(HaveOccurred())

			err = clientcmd.ConfirmUsable(*config, "")
			Expect(err).ShouldNot(HaveOccurred())

			Expect(config.CurrentContext).To(ContainSubstring("eksctl"))
		})*/

		Context("and we create a deployment using kubectl", func() {
			var (
				kube *harness.Harness
			)

			BeforeEach(func() {
				opts := harness.Options{
					Kubeconfig: pathKubeCtlConf,
					Logger:     &logger.TestLogger{},
				}
				kube = harness.New(opts)
			})

			It("should deploy the service to the cluster", func() {
				test := kube.NewTest(GinkgoT()).Setup()
				defer test.Close()

				d := test.CreateDeploymentFromFile("default", "nginx-deployment.yaml")
				test.WaitForDeploymentReady(d, 1*time.Minute)

				// For each pod of the Deployment, check we receive a sensible response to a
				// GET request on /.
				for _, pod := range test.ListPodsFromDeployment(d).Items {
					_, err := test.PodProxyGet(&pod, "80", "/").DoRaw()

					Expect(err).ShouldNot(HaveOccurred())
					//TODO: compare response???
				}
			})
		})
	})
})

func init() {
	flag.StringVar(&pathToEksCtl, "eksctl-path", "./eksctl", "Path to eksctl")

	// Flags to help with the development of the integration tests
	flag.BoolVar(&skipCreation, "skip-creation", false, "Skip the creation tests. Useful for debugging the tests")
	flag.BoolVar(&skipCleanup, "skip-cleanup", false, "Skip the cleanup after the tests have run")
	flag.StringVar(&pathKubeCtlConf, "kubeconf-path", "", "Path to kubectl config. Default is to create a temporary file")
}
